# [x] Write an expression to raise a `ModuleNotFoundError` exception
datetime.today()

# [x] Write an expression to raise an `ImportError` exception
from math import randon

# [x] The following program adds `lst1` to `lst2` element by element
# Find all exceptions that will be generated by this program,
# then handle the exceptions by displaying meaningful messages.
# You should also handle unexpected exceptions.
lst1 = [-4, -5,   6,   [6], "hello"]
lst2 = [ 5, 16, [6], "hello", "goodbye"]
for i in range(7):
    try:
        print(lst1[i] + lst2[i])
    except Exception as exception_object:
        print("Unexpected error: {0:}".format(exception_object))

# [x] The following program asks the user for an integer then prints the result of dividing it by 2.
# If the user enters an invalid value (i.e. "4.3" or "Hello"), the program terminates.
# Use exception handling to deal with unexpected user input and display a meaningful message.
try:
    x = input("Enter an integer: ")
    x = int(x)
    print("{:d} / 2 = {:.2f}".format(x, x / 2))
    print("Done!")
except Exception as exception_object:
    print("Unexpected error: {0:}".format(exception_object))

# [x] The following program asks the user for an integer `x` then assigns `y` as the result of dividing `x` by 2.
# If the user enters an invalid value (i.e. "4.3" or "Hello"), the program terminates.
# Use exception handling to deal with unexpected user inputs, then use an `else` clause to calculate the value of `y`.
try:
    x = input("Enter an integer: ")
    y = None
    x = int(x)
    y = x / 2
except ValueError as exception_object: # Storing the error message in exception_object
    print(exception_object)  
else:
    print("No exceptions were raised, you can use y =", y)

# [x] The following program tries to write to a file opened for reading.
# The program will terminate before closing the file, and the file resources will not be released.
# Use exception handling with a `finally` clause to make sure the file is closed.

try:
# Open a text file for reading
    f = open("parent_dir/text_file.txt", 'r')
# Try to write to a file open for reading (will raise an exception)
    f.write("This string will not be written")
except FileNotFoundError as exception_object: # Storing the error message in exception_object
    print(exception_object)   
finally:
    try:
        f.close()
    except NameError as exception_object: # Storing the error message in exception_object
        print(exception_object)
    print("File closed")

# [x] Write a program to keep prompting the user for an odd positive number until a valid number is entered.
# Your program should raise an exception with an appropriate message if the input is not valid.
def isValid(num):
    if num < 0:
        raise ValueError("The number is negative !")
    elif num%2 == 0:
        raise ValueError("The number is not odd !")     
    else:
        return num
valid = False
while not valid:
    try:
        x = int(input("Enter an odd positive number: "))
        x = isValid(x)
        valid = True
    except ValueError as except_object:
        print("{}".format(except_object))
print("{:d} was accepted".format(x))

# [x] Complete the function `isValid` to test the validity of a user input. A valid input should be an odd positive integer.
# The function should raise an exception with an appropriate message if the input is not valid.
# The function need not handle the exception.
def isValid(num):
    if num < 0:
        raise ValueError("The number is negative !")
    elif num%2 == 0:
        raise ValueError("The number is not odd !")     
    else:
        return num    
valid = False
while not valid:
    try:
        x = int(input("Enter an odd positive number: "))
        x = isValid(x)
        valid = True
    except ValueError as except_object:
        print("{}".format(except_object))
print("{:d} was accepted".format(x))


